/**
 * Generates gameMetadata.ts from the individual metadata.ts files in games/ and apps/.
 * Run with: pnpm generate:metadata (or npx tsx scripts/generate-game-metadata.ts)
 */

import * as fs from "fs";
import * as path from "path";

const SRC_DIR = path.join(__dirname, "..", "src");
const OUTPUT_FILE = path.join(SRC_DIR, "shared", "lib", "gameMetadata.generated.ts");

interface ParsedMetadata {
  id: string;
  name: string;
  emoji: string;
  category: string;
  description?: string;
}

function parseMetadataFile(filePath: string): ParsedMetadata | null {
  try {
    const content = fs.readFileSync(filePath, "utf-8");

    const idMatch = content.match(/id:\s*["']([^"']+)["']/);
    const nameMatch = content.match(/name:\s*["']([^"']+)["']/);
    const emojiMatch = content.match(/emoji:\s*["']([^"']+)["']/);
    const categoryMatch = content.match(/category:\s*["']([^"']+)["']/);
    const descMatch = content.match(/description:\s*["']([^"']+)["']/);

    if (!idMatch || !nameMatch || !emojiMatch || !categoryMatch) {
      console.warn(`Missing required fields in ${filePath}`);
      return null;
    }

    return {
      id: idMatch[1],
      name: nameMatch[1],
      emoji: emojiMatch[1],
      category: categoryMatch[1],
      description: descMatch?.[1],
    };
  } catch (err) {
    console.error(`Error parsing ${filePath}:`, err);
    return null;
  }
}

function scanDirectory(type: "games" | "apps"): ParsedMetadata[] {
  const items: ParsedMetadata[] = [];
  const dir = path.join(SRC_DIR, type);

  if (!fs.existsSync(dir)) {
    console.warn(`Directory not found: ${dir}`);
    return items;
  }

  const entries = fs.readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    if (!entry.isDirectory()) continue;

    const metadataPath = path.join(dir, entry.name, "metadata.ts");
    if (fs.existsSync(metadataPath)) {
      const metadata = parseMetadataFile(metadataPath);
      if (metadata) {
        items.push(metadata);
      }
    }
  }

  return items;
}

// Color mapping based on category (keeping existing pattern)
const CATEGORY_COLORS: Record<string, string> = {
  racing: "green",
  board: "amber",
  arcade: "orange",
  action: "cyan",
  puzzle: "purple",
  retro: "violet",
  apps: "pink",
};

function generateOutput(items: ParsedMetadata[]): string {
  const entries = items
    .map((item) => {
      const color = CATEGORY_COLORS[item.category] || "gray";
      return `  "${item.id}": {
    name: "${item.name}",
    icon: "${item.emoji}",
    color: "${color}",
    description: "${item.description || ""}",
    category: "${item.category}",
  }`;
    })
    .join(",\n");

  return `/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * Generated by: pnpm generate:metadata
 * Source: Individual metadata.ts files in src/games/ and src/apps/
 */

import type { CategoryId } from "./game-registry";

export interface GameMetadata {
  name: string;
  icon: string;
  color: string;
  description: string;
  category: CategoryId;
}

export const GAME_METADATA: Record<string, GameMetadata> = {
${entries},
};

/**
 * Get metadata for a game by its appId.
 * Returns a default if game not found.
 */
export function getGameMetadata(appId: string): GameMetadata {
  return (
    GAME_METADATA[appId] || {
      name: appId,
      icon: "ðŸŽ®",
      color: "gray",
      description: "A game",
      category: "arcade" as CategoryId,
    }
  );
}

/**
 * Static gradient class map - Tailwind can't analyze dynamic classes.
 */
const GRADIENT_MAP: Record<string, string> = {
  green: "from-green-500 to-green-700",
  red: "from-red-500 to-red-700",
  amber: "from-amber-500 to-amber-700",
  slate: "from-slate-500 to-slate-700",
  emerald: "from-emerald-500 to-emerald-700",
  sky: "from-sky-500 to-sky-700",
  orange: "from-orange-500 to-orange-700",
  lime: "from-lime-500 to-lime-700",
  purple: "from-purple-500 to-purple-700",
  yellow: "from-yellow-500 to-yellow-700",
  cyan: "from-cyan-500 to-cyan-700",
  blue: "from-blue-500 to-blue-700",
  pink: "from-pink-500 to-pink-700",
  stone: "from-stone-500 to-stone-700",
  indigo: "from-indigo-500 to-indigo-700",
  violet: "from-violet-500 to-violet-700",
  gray: "from-gray-500 to-gray-700",
};

/**
 * Get Tailwind background gradient classes for a game.
 */
export function getGameGradient(appId: string): string {
  const { color } = getGameMetadata(appId);
  return GRADIENT_MAP[color] || GRADIENT_MAP.gray;
}
`;
}

// Main
const games = scanDirectory("games");
const apps = scanDirectory("apps");
const allItems = [...games, ...apps];

console.log(`Found ${games.length} games and ${apps.length} apps`);

const output = generateOutput(allItems);
fs.writeFileSync(OUTPUT_FILE, output);

console.log(`Generated ${OUTPUT_FILE}`);
